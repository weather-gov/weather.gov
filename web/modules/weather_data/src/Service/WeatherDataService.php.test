<?php

namespace Drupal\weather_data\Service;

include_once "WeatherDataService.php";

use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\StringTranslation\TranslationInterface;
use GuzzleHttp\Client;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Handler\MockHandler;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\Psr7\Response;
use PHPUnit\Framework\ExpectationFailedException;
use PHPUnit\Framework\TestCase;

/**
 * Tests for the WeatherDataService getCurrentConditions method.
 */
final class WeatherDataServiceGetCurrentConditionsTest extends TestCase {
  /**
   * The mocked HTTP client.
   *
   * @var httpClientMock
   */
  protected $httpClientMock;

  /**
   * The mocked route object.
   *
   * @var routeMock
   */
  protected $routeMock;

  /**
   * The WeatherDataService object under test.
   *
   * @var weatherDataService
   */
  protected $weatherDataService;

  /**
   * Common setup for all component tests.
   */
  protected function setUp() : void {
    parent::setUp();

    $this->httpClientMock = new MockHandler([]);
    $stack = HandlerStack::create($this->httpClientMock);
    $client = new Client(['handler' => $stack]);

    // Just return the input string. The translation manager is tested by Drupal
    // so we don't need to.
    $translationManager = $this->createStub(TranslationInterface::class);
    $translationManager->method('translate')->will(
      $this->returnCallback(
        function ($str) {
          return $str;
        }
      )
    );

    $this->weatherDataService = new WeatherDataService($client, $translationManager);

    $this->routeMock = $this->createStub(RouteMatchInterface::class);
    $this->routeMock->method('getRouteName')->willReturn('weather_routes.grid');
    $this->routeMock->method('getParameter')->WillReturnMap([
      ['wfo', 'NWS'],
      ['gridX', 10],
      ['gridY', 10],
      ['location', 'National Weather Service'],
    ]);
  }

  /**
   * Sets up the HTTP mock for a happy-path of API data for an observation.
   */
  public function setupHappyPath($whichObservation) {
    $this->httpClientMock->append(
      new Response(200,
        ['Content-type' => 'application/geo+json'],
        file_get_contents(__DIR__ . "/test_data/observation-stations.good.json")
      )
    );
    $this->httpClientMock->append(
      new Response(200,
        ['Content-type' => 'application/geo+json'],
        file_get_contents(__DIR__ . "/test_data/" . $whichObservation)
      ),
    );

    return [
      "conditions" => [
        "long" => "Snow",
        "short" => "Snow",
      ],
      "feels_like" => 45,
      "humidity" => 88,
      "icon" => "snow.svg",
      "location" => "National Weather Service",
      "temperature" => 45,
      "timestamp" => [
        "formatted" => "Thursday 8:00 PM GMT+0000",
        "utc" => "1697140800",
      ],
      "wind" => [
        "speed" => 13,
        "angle" => 310,
        "direction" => "northwest",
        "shortDirection" => "NW",
      ],
    ];
  }

  /**
   * Tests the happy path with no "feels like" temperature.
   */
  public function testHappyPathWithNoFeelsLike(): void {
    $expected = $this->setupHappyPath("observation.good-no-feelslike.json");

    $actual = $this->weatherDataService->getCurrentConditions($this->routeMock);

    $this->assertEquals((object) $expected, (object) $actual);
  }

  /**
   * Tests the happy path with a heat index.
   */
  public function testHappyPathWithHeatIndex(): void {
    $expected = $this->setupHappyPath("observation.good-heatindex.json");
    $expected["feels_like"] = 117;

    $actual = $this->weatherDataService->getCurrentConditions($this->routeMock);

    $this->assertEquals((object) $expected, (object) $actual);
  }

  /**
   * Tests the happy path with a wind chill.
   */
  public function testHappyPathWithWindChill(): void {
    $expected = $this->setupHappyPath("observation.good-windchill.json");
    $expected["feels_like"] = 16;

    $actual = $this->weatherDataService->getCurrentConditions($this->routeMock);

    $this->assertEquals((object) $expected, (object) $actual);
  }

  /**
   * Tests the happy path with both heat index and wind chill.
   */
  public function testHappyPathWithHeatIndexAndWindChill(): void {
    $expected = $this->setupHappyPath("observation.good-both.json");
    $expected["feels_like"] = 194;

    $actual = $this->weatherDataService->getCurrentConditions($this->routeMock);

    $this->assertEquals((object) $expected, (object) $actual);
  }

  /**
   * Tests the case where the icon is null.
   */
  public function testIconIsNull(): void {
    $expected = $this->setupHappyPath("observation.bad-null-icon.json");
    $expected["icon"] = "nodata.svg";
    $expected["conditions"]["short"] = "No data";
    $expected["conditions"]["long"] = "No data";

    $actual = $this->weatherDataService->getCurrentConditions($this->routeMock);

    $this->assertEquals((object) $expected, (object) $actual);
  }

  /**
   * Tests the case where the icon is an empty string.
   */
  public function testIconIsEmptyString(): void {
    $expected = $this->setupHappyPath("observation.bad-empty-icon.json");
    $expected["icon"] = "nodata.svg";
    $expected["conditions"]["short"] = "No data";
    $expected["conditions"]["long"] = "No data";

    $actual = $this->weatherDataService->getCurrentConditions($this->routeMock);

    $this->assertEquals((object) $expected, (object) $actual);
  }

  /**
   * Tests that the wind direction is populated correctly.
   *
   * This tests the 8 cardinal and ordinal directions.
   */
  public function testWindDirections(): void {
    $scenarios = [
      [0, "north", "N"],
      [45, "northeast", "NE"],
      [90, "east", "E"],
      [135, "southeast", "SE"],
      [180, "south", "S"],
      [225, "southwest", "SW"],
      [270, "west", "W"],
      [315, "northwest", "NW"],
      [360, "north", "N"],
    ];

    $observationResponse = json_decode(file_get_contents(__DIR__ . "/test_data/observation.good-no-feelslike.json"));

    $expected = [
      "conditions" => [
        "long" => "Snow",
        "short" => "Snow",
      ],
      "feels_like" => 45,
      "humidity" => 88,
      "icon" => "snow.svg",
      "location" => "National Weather Service",
      "temperature" => 45,
      "timestamp" => [
        "formatted" => "Thursday 8:00 PM GMT+0000",
        "utc" => "1697140800",
      ],
      "wind" => [
        "speed" => 13,
        "angle" => 310,
        "direction" => "northwest",
        "shortDirection" => "NW",
      ],
    ];

    foreach ($scenarios as $scenario) {
      // Re-create the WeatherDataService object so we don't get cached results.
      $this->setUp();

      $observationResponse->features[0]->properties->windDirection->value = $scenario[0];

      $expected["wind"]["angle"] = $scenario[0];
      $expected["wind"]["direction"] = $scenario[1];
      $expected["wind"]["shortDirection"] = $scenario[2];

      $this->httpClientMock->append(
        new Response(200,
          ['Content-type' => 'application/geo+json'],
          file_get_contents(__DIR__ . "/test_data/observation-stations.good.json")
        )
      );
      $this->httpClientMock->append(
        new Response(200,
          ['Content-type' => 'application/geo+json'],
          json_encode($observationResponse)
        ),
      );

      $actual = $this->weatherDataService->getCurrentConditions($this->routeMock);

      $this->assertEquals((object) $expected, (object) $actual);
    }
  }

  /**
   * Tests that curent conditions results are cached.
   */
  public function testCaching(): void {
    // First setup the API to return no feels-like temperature and get the
    // conditions accordingly.
    $expected = $this->setupHappyPath("observation.good-no-feelslike.json");
    $this->weatherDataService->getCurrentConditions($this->routeMock);

    // Now setup the API to return both heat index and wind chill and get the
    // conditions again.
    $this->setupHappyPath("observation.good-both.json");
    $actual = $this->weatherDataService->getCurrentConditions($this->routeMock);

    // The output from the second call should be the based on the no-feels-like
    // setup because the results should be cached. The API should not be called
    // again.
    $this->assertEquals((object) $expected, (object) $actual);
  }

  /**
   * Tests asking for current conditions when not on a grid route.
   */
  public function testNotGridRoute(): void {
    // Create a one-off stub because phpunit doesn't allow overriding a return
    // value from a stub once it's set. It's just set forever. And rather than
    // changing the setup() method that works for most of these tests, we'll
    // just work around it.
    // https://github.com/sebastianbergmann/phpunit-mock-objects/issues/260
    $routeMock = $this->createStub(RouteMatchInterface::class);
    $routeMock->method('getRouteName')->willReturn('weather_routes.not-grid');

    $actual = $this->weatherDataService->getCurrentConditions($routeMock);

    $this->assertEquals(NULL, $actual);
  }

}

/**
 * Tests for the WeatherDataService getGridFromLatLon method.
 */
final class WeatherDataServiceGetGridFromLatLon extends TestCase {
  /**
   * The mocked HTTP client.
   *
   * @var httpClientMock
   */
  protected $httpClientMock;

  /**
   * The WeatherDataService object under test.
   *
   * @var weatherDataService
   */
  protected $weatherDataService;

  /**
   * Common setup for all component tests.
   */
  protected function setUp() : void {
    parent::setUp();

    $this->httpClientMock = new MockHandler([]);
    $stack = HandlerStack::create($this->httpClientMock);
    $client = new Client(['handler' => $stack]);

    $translationManager = $this->createStub(TranslationInterface::class);

    $this->weatherDataService = new WeatherDataService($client, $translationManager);
  }

  /**
   * Tests the happy path.
   */
  public function testHappyPath(): void {
    $this->httpClientMock->append(
      new Response(200,
        ['Content-type' => 'application/geo+json'],
        json_encode([
          "properties" => [
            "gridId" => "the wfo",
            "gridX" => "an x",
            "gridY" => "a y",
            "relativeLocation" => [
              "properties" => [
                "city" => "place",
              ],
            ],
          ],
        ]),
      ),
    );

    $expected = [
      "wfo" => "the wfo",
      "gridX" => "an x",
      "gridY" => "a y",
      "location" => "place",
    ];

    $actual = $this->weatherDataService->getGridFromLatLon(1, 2);

    $this->assertEquals((object) $expected, (object) $actual);
  }

  /**
   * Tests when we get a request error.
   */
  public function testErrorCondition(): void {
    $this->httpClientMock->append(
      new RequestException('', new Request('GET', ''))
    );

    $actual = $this->weatherDataService->getGridFromLatLon(1, 2);

    $this->assertEquals(NULL, $actual);
  }

}

/**
 * Tests that the legacy mapping only returns icons that we actually have.
 */
final class WeatherDataLegacyIconMapping extends TestCase {

  /**
   * Asdf.
   */
  public function testIconMapping() : void {
    $path = realpath(__DIR__ . "/../../../../themes/new_weather_theme/assets/images/weather/icons/conditions/");

    $failures = [];

    $mappings = json_decode(file_get_contents(__DIR__ . "/legacyMapping.json"));
    foreach ($mappings as $condition) {
      try {
        $this->assertFileExists($path . "/" . $condition->icon);
      }
      catch (ExpectationFailedException $e) {
        $failures[] = $e->getMessage();
      }
    }

    if (!empty($failures)) {
      throw new ExpectationFailedException(
        count($failures) . " assertions failed:\n\t" . implode("\n\t", $failures)
      );
    }
  }

}
